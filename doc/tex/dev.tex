\chapter{development}
\label{ch:dev}

This chapter covers the best practices 
for contributing to \verb|slacx| via git (section~\ref{sec:slacx_dev})
and instructions for developing operations
for use in the \verb|slacx| workflow engine (section~\ref{sec:op_dev}).
These instructions are intended for people
who are familiar with the \verb|slacx| development team
and have received an invitation to work in their private repository.
Public forking of the repository is not currently allowed.

\section{contributing to slacx}
\label{sec:slacx_dev}

The \verb|slacx| repository is currently private.
Request access by getting in touch with the \verb|slacx| developers.
Try \verb|slacx-developers@slac.stanford.edu|. 
If you are looking for a long term relationship,
you can send an email to join the slacx-developers listserv.
Send an email to \newline
\verb|listserv@listserv.slac.stanford.edu| \newline
with no subject and the following text in the body: \newline
\verb|CHARSET UTF-8 ADD SLACX-DEVELOPERS <your@email.address> <Your Name>|

Code development is currently following the ``shared repository model'',
meaning developers have write access to the main repository.
In this model, you must be careful with your edits.
In particular, \textbf{all coding should be done in feature branches}.
Never push changes directly to the \verb|dev| or \verb|master| branches.
If you do, we will roll back the problematic changes, 
and initiate the process outlined below for pulling the new feature into \verb|dev|.

The repository has a \verb|master| branch that is intended to be the most stable version,
and a \verb|dev| branch that is intended for development.
The rest of the branches are feature branches.
Once you have access, clone the repository
and create your own development or feature branch.
When you are satisfied, make sure your feature is current with \verb|dev|
and submit a pull request from your feature branch to \verb|dev|.
Below are are step-by-step instructions for the command line.
Non-CLI \verb|git| clients should expose intuitive analogous procedures.

\begin{itemize} 
\item Clone the repository: \verb|git clone https://lensonp@bitbucket.org/smashml/slacx.git|.
    This should create a local source code directory.
    Descend into that directory.
\item Create a \verb|dev| branch that tracks the origin's \verb|dev| branch.
    Simply, you can use \verb|git checkout dev|, which is implied shorthand for
    \verb|git checkout --track origin/dev|, which is shorthand for
    \verb|git checkout -b dev origin/dev|. 
\item Create your own feature branch: \verb|git branch my-feature-branch| 
\end{itemize} 
\textbf{--- start here every time you work on your feature ---}
\begin{itemize} 
\item Check out your feature branch: \verb|git checkout my-feature-branch|
\item Download the latest \verb|dev| commits from origin: \verb|git fetch origin| 
\item Rebase on the \verb|dev| branch: \verb|git rebase dev|
    Review any conflicts and resolve them locally in your feature branch.
\item Work on your feature.
\item After working, stage your edits: \verb|git add .|
\item After staging your edits, commit them with a description: 
    \verb|git commit -m 'description of edits'|
\item Push your commits to origin: \verb|git push origin my-feature-branch|
\end{itemize} 
\textbf{--- start here when you are done with your feature ---}
\begin{itemize} 
\item Download the latest \verb|dev| commits from origin: \verb|git fetch origin| 
\item Rebase on the \verb|dev| branch: \verb|git rebase dev|
\item Push your commits to origin: \verb|git push origin my-feature-branch|
\item Submit a pull request via the online interface.
    Request to pull \verb|my-feature-branch| into \verb|dev|.
    The \verb|slacx| development team will discuss, edit, 
    and ultimately accept your feature.
\end{itemize} 

\section{developing operations for slacx}
\label{sec:op_dev}

Developing operations for use in the \verb|slacx| workflow engine 
is meant to be as painless as possible.
A continuing effort will be made to streamline this process.

The most general description of an operation 
is to treat it as a black box that takes some inputs (data and parameters),
performs some processing with those inputs,
and produces some output (data and other features).
Users can choose to build their operations in two ways.

One option is to write the function into a python class
that defines names for its inputs and outputs
and then stores the input and output data 
within instances (objects) of that class.
This process is most easily understood 
by following the template and instructions 
provided in section~\ref{sec:op_dev_by_class} below.

Another option (not yet implemented)
is to write the function into a python module 
that contains formatted metadata 
about how the function should be called,
with input and output data 
stored in the workflow engine itself.

In either case, the user/developer writes their operation 
into a module \verb|somefile.py|
and then places this module in the \verb|slacx/core/operations/| directory.
If the implementation obeys the specified format, 
the operation will automatically be made available 
to the \verb|slacx| workflow manager
the next time \verb|slacx| is started.
If the user/developer is not careful 
about implementing their operation,
\verb|slacx| will probably raise exceptions and exit. 
This could happen at startup (when the operation is read),
during workflow management (when the operations is loaded with inputs),
or during execution (when the operation is called upon to compute things),
depending on where (if any) errors were made.


\subsection{operations as python classes}
\label{sec:op_dev_by_class}

The following code block gives a minimal, 
commented template for developing
operations as python classes.
Users/developers with some programming background
may find all the information they need in this template alone.

\begin{lstlisting}
# Users and developers should remove all comments from this template.
# All text outside comments that is meant to be removed or replaced 
# is <written within angle brackets>.

# Operations implemented as python classes 
# have a common interface for communicating 
# with the slacx workflow manager.
# That common interface is ensured by inheriting it
# from an abstract class called 'Operation'.
from core.operations.slacxop import Operation

# Name the operation, specify inheritance (Operation)
class <OperationName>(Operation):
    # Give a brief description of the operation
    # bracketed by """triple-double-quotes"""
    """<Description of Operation>"""

    # Write an __init__() function for the Operation.
    def __init__(self):
        # Name the input and output data/parameters for your operation.
        # Format names as 'single_quotes_without_spaces'.
        input_names = ['<input_name_1>','<input_name_2>',<...>]
        output_names = ['<output_name_1>','<output_name_2>',<...>]
        # Call the __init__ method of the Operation abstract (super)class.
        # This instantiates {key:value} dictionaries of inputs and outputs, 
        # which have keys generated from input_names and output_names.
        # All values in the dictionary are initialized as None. 
        super(Identity,self).__init__(input_names,output_names)
        # Write a free-form documentation string describing each item
        # that was named in input_names and output_names.
        self.input_doc['<input_name_1>'] = '<expectations for input 1>'
        self.input_doc['<input_name_2>'] = '<etc>'
        self.output_doc['<output_name_1>'] = '<form of output 1>'
        self.output_doc['<output_name_2>'] = '<etc>'
        # Categorize the operation. Multiple categories are acceptable.
        # Indicate subcategories with a '.' character.
        self.categories = ['<CAT1>','<CAT2>.<SUBCAT1>',<...>]
        
    # Write a run() function for this Operation.
    def run(self):
        # Optional- create references in the local namespace for cleaner code.
        <inp1> = self.inputs['<input_name_1>']
        <inp2> = self.inputs['<input_name_2>']
        <etc>
        # Perform the computation
        < ... >
        # Save the outputs
        self.outputs['<output_name_1>'] = <computed_value_1>
        self.outputs['<output_name_2>'] = <etc>
\end{lstlisting}


\subsection{operations as functions in a module}
\label{sec:op_dev_by_function}

This functionality is not yet implemented.

